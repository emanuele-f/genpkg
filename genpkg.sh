#!/bin/bash
# Emanuele Faranda
#
# A script to generate Arch Linux packages from local sources.
#
PKGDIR=
PKGFILE=

SOURCE_DIR=
USE_DEFAULTS=0
DO_INSTALL=0
JUST_PKGBUILD=0
CUSTOM_PKG_DIR=0
CUSTOM_PKGBUILD=

PKG_NAME=
PKG_VERSION=
PKG_ARCH="'$(uname -m)'"
PKG_DEPENDS=
PKG_CONFLICTS=
PKG_PROVIDES=

function usage {
  cat >&2 << EOF
Usage: `basename $0` [options] source_dir

Options:
 -d         do not prompt for configuration but use default
 -i         do not copy built package to current dir, just install it
 -p         just save the generated PKGBUILD to the current directory and exit
 -s [file]  use the provided file as PKGBUILD
EOF

  exit 1
}

QUOTED=
function to_quoted {
  QUOTED=()
  
  for x in $1; do
    QUOTED+=("'$x'")
  done
}

function cleanup {
  if [[ $CUSTOM_PKG_DIR -eq 0 ]]; then
    rm -rf $PKGDIR 2>/dev/null
  fi
}

function check_return {
  local ev=$?
  if [[ $ev -ne 0 ]]; then
    echo "Exit with code $ev" >&2
    cleanup
    exit $ev
  fi
}

function term_handler {
  cleanup
  echo -e "\nAbort"
  exit 1
}

function init_pkg_info {
  local dname="${SOURCE_DIR##*/}"
  
  if [[ -d "$SOURCE_DIR/.git" ]]; then
    # From git release
    PKG_NAME="$dname"
    cd "$SOURCE_DIR"
    PKG_VERSION=`printf "r%s.%s" $(git rev-list --count HEAD) $(git rev-parse --short HEAD)`
    cd - >/dev/null
  else
    # From directory name
    PKG_NAME="${dname%%-*}"
    PKG_VERSION="${dname##*-}"
  fi
}

function read_config {
  # get values
  echo -n "New package name: ($PKG_NAME): "; read tmp
  if [ x"$tmp" != x ]; then 
    PKG_NAME="$tmp"
  fi

  echo -n "Version: ($PKG_VERSION): "; read tmp
  if [ x"$tmp" != x ]; then
    PKG_VERSION="$tmp"
  fi

  echo -n "Architectures (space separated): ($PKG_ARCH): "; read tmp
  if [ x"$tmp" != x ]; then 
    to_quoted "$tmp"
    PKG_ARCH="${QUOTED[@]}"
  fi

  echo -n "Depends (space separated): ($PKG_DEPENDS): "; read tmp
  if [ x"$tmp" != x ]; then
    to_quoted "$tmp"
    PKG_DEPENDS="${QUOTED[@]}"
  fi
  
  echo -n "Conflicts (space separated): ($PKG_CONFLICTS): "; read tmp
  if [ x"$tmp" != x ]; then
    to_quoted "$tmp"
    PKG_CONFLICTS="${QUOTED[@]}"
  fi

  echo -n "Provides (space separated): ($PKG_PROVIDES): "; read tmp
  if [ x"$tmp" != x ]; then
    to_quoted "$tmp"
    PKG_PROVIDES="${QUOTED[@]}"
  fi
}

# Main
[[ $UID -eq 0 ]] && echo "WARNING: should not run as root" >&2

while [[ ! -z "$1" ]]; do
  case "$1" in
    -d) USE_DEFAULTS=1;;
    -i) DO_INSTALL=1;;
    -p) CUSTOM_PKG_DIR=1; PKGDIR="."; JUST_PKGBUILD=1;;
    -s) shift; CUSTOM_PKGBUILD="$1";;
     *) [[ -z "$SOURCE_DIR" ]] && SOURCE_DIR=`readlink -f "$1"` || usage
  esac
  
  shift
done

[[ -z "$SOURCE_DIR" ]] && usage

if [[ ! -d "$SOURCE_DIR" ]]; then
  echo "'$SOURCE_DIR' is not a directory" >&2
  exit 1
fi

init_pkg_info

if [[ -z "$PKGDIR" ]];then
  CUSTOM_PKG_DIR=0
  PKGDIR=`mktemp -d`
fi
PKGFILE="$PKGDIR/PKGBUILD.$PKG_NAME"

trap term_handler SIGTERM SIGINT SIGHUP

if [[ -z "$CUSTOM_PKGBUILD" ]]; then
  [[ $USE_DEFAULTS -eq 0 ]] && read_config

  cat > $PKGFILE << EOF
# Generated by pkkgen
pkgname=$PKG_NAME
pkgver=$PKG_VERSION
pkgrel=1
pkgdesc=
arch=($PKG_ARCH)
url=
license=()
depends=($PKG_DEPENDS)
makedepends=()
provides=($PKG_PROVIDES)
conflicts=($PKG_CONFLICTS)

package() {
  cd "$SOURCE_DIR"
  make DESTDIR="\${pkgdir}" install
}
EOF

  check_return
else
  cp "$CUSTOM_PKGBUILD" "$PKGFILE"; check_return
fi

[[ $JUST_PKGBUILD -eq 1 ]] && exit 0

(cd $PKGDIR && makepkg --force -p "$PKGFILE"; check_return)

# find out which is the generated source file
generated="`find $PKGDIR -maxdepth 1 -type f -name '*.pkg.*'`"
if [[ -z "$generated" || $(echo "$generated" | wc -l) -ne 1 ]]; then
  echo "Cannot figure out the generated package name, please specify it manually."
  echo "Available files:"
  for tmp in `find $PKGDIR -maxdepth 1 -type f`; do
    echo -e "\t`basename $tmp`"
  done
  echo -n "> "

  read tmp
  fulltmp="$PKGDIR/$tmp"
  if [[ x"$tmp" == x || ! -f "$fulltmp" ]]; then
    echo "Cannot read input file. Please checkout '$PKGDIR' manually."
    exit 1
  fi

  generated="$fulltmp"
fi

if [[ $DO_INSTALL -eq 1 ]]; then
  cmd="pacman -U --force $generated"
  [[ $UID -ne 0 ]] && cmd="sudo $cmd"
  $cmd; check_return
else
  cp "$generated" ./
fi

cleanup
exit 0
